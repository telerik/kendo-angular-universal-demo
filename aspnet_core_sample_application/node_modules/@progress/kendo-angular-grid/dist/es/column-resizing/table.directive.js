import { ChangeDetectorRef, Directive, ElementRef, HostBinding, Input, NgZone, Renderer2 } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/bufferCount';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/switchMap';
import 'rxjs/add/operator/do';
import 'rxjs/add/operator/map';
import { resizableColumns } from '../columns/column-common';
import { ColumnResizingService } from './column-resizing.service';
/**
 * @hidden
 */
var columnsToResize = function (_a) {
    var columns = _a.columns;
    return Math.max(1, resizableColumns(columns).length - 1);
};
/**
 * @hidden
 */
var row = function (selector) { return function (element) { return element.querySelector(selector); }; };
/**
 * @hidden
 */
var headerRow = function (index) { return function (element) { return element.querySelectorAll('thead>tr')[index]; }; };
/**
 * @hidden
 */
var cell = function (index, selector) {
    if (selector === void 0) { selector = 'td'; }
    return function (element) {
        return element.querySelectorAll(selector + ":not(.k-group-cell):not(.k-hierarchy-cell)")[index];
    };
};
/**
 * @hidden
 */
var offsetWidth = function (element) { return element.offsetWidth; };
/**
 * @hidden
 */
var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (data) { return fns.reduce(function (state, fn) { return state ? fn(state) : 0; }, data); };
};
/**
 * @hidden
 */
var TableDirective = (function () {
    function TableDirective(element, renderer, service, zone, cdr) {
        this.element = element;
        this.renderer = renderer;
        this.service = service;
        this.zone = zone;
        this.cdr = cdr;
        this.locked = false;
        this.firstResize = false;
    }
    Object.defineProperty(TableDirective.prototype, "minWidth", {
        get: function () {
            return this.firstResize ? 0 : null;
        },
        enumerable: true,
        configurable: true
    });
    TableDirective.prototype.ngOnInit = function () {
        var _this = this;
        var obs = this.service
            .changes
            .filter(function (e) { return _this.locked === e.locked; });
        this.subscription = obs
            .filter(function (e) { return e.type === 'start'; })
            .do(this.initState.bind(this))
            .map(columnsToResize)
            .switchMap(function (take) {
            return obs
                .filter(function (e) { return e.type === 'resizeTable'; })
                .map(function (e) { return e.delta; })
                .bufferCount(take);
        })
            .subscribe(this.resize.bind(this));
        this.autoFitSubscription = this.service
            .registerTable(this.autoFitObservable.bind(this));
    };
    TableDirective.prototype.ngOnDestroy = function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.autoFitSubscription();
    };
    TableDirective.prototype.initState = function () {
        this.firstResize = true;
        this.originalWidth = offsetWidth(this.element.nativeElement);
    };
    TableDirective.prototype.resize = function (deltas) {
        var delta = deltas.reduce(function (sum, item) { return sum + item; }, 0);
        this.updateWidth(this.originalWidth + delta);
    };
    TableDirective.prototype.updateWidth = function (width) {
        this.renderer.setStyle(this.element.nativeElement, 'width', width + 'px');
        this.cdr.detectChanges(); //force CD cycle
    };
    TableDirective.prototype.autoFitObservable = function (columnInfo) {
        var _this = this;
        return Observable.create(function (observer) {
            _this.zone.runOutsideAngular(function () {
                _this.renderer.addClass(_this.element.nativeElement, 'k-autofitting');
                _this.cdr.detectChanges(); //force CD cycle
                var widths = columnInfo.map(_this.measureColumn.bind(_this));
                _this.renderer.removeClass(_this.element.nativeElement, 'k-autofitting');
                observer.next(widths);
            });
        });
    };
    TableDirective.prototype.measureColumn = function (info) {
        var dom = this.element.nativeElement;
        var header = pipe(headerRow(info.level), cell(info.headerIndex, 'th'), offsetWidth)(dom);
        var data = 0;
        if (!info.isParentSpan || (info.isParentSpan && info.isLastInSpan)) {
            data = pipe(row('tbody>tr:not(.k-grouping-row)'), cell(info.index), offsetWidth)(dom);
        }
        var footer = pipe(row('tfoot>tr'), cell(info.index), offsetWidth)(dom);
        return Math.max(header, data, footer);
    };
    return TableDirective;
}());
export { TableDirective };
TableDirective.decorators = [
    { type: Directive, args: [{
                selector: 'table' // tslint:disable-line:directive-selector
            },] },
];
/** @nocollapse */
TableDirective.ctorParameters = function () { return [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: ColumnResizingService, },
    { type: NgZone, },
    { type: ChangeDetectorRef, },
]; };
TableDirective.propDecorators = {
    'locked': [{ type: Input },],
    'minWidth': [{ type: HostBinding, args: ['style.min-width',] },],
};
